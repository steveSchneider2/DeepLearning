# -*- coding: utf-8 -*-
"""TF2.0 CIFAR.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1hR5IlAM9mDNgto8PeM1MqdYatmiLJM3q
128 Second duration!!


"""

# Commented out IPython magic to ensure Python compatibility.
# Install TensorFlow
# !pip install -q tensorflow-gpu==2.0.0-beta1

#try:
##   %tensorflow_version 2.x  # Colab only.
#except Exception:
#  pass
#%% Imports
import time
import sys
import os
import tensorflow as tf
import numpy as np
import matplotlib.pyplot as plt
from tensorflow.keras.layers import Input, Conv2D, Dense, Flatten, Dropout, GlobalMaxPooling2D
from tensorflow.keras.models import Model
import pydot
import graphviz  # this was not enough.  needed python-graphviz

# following line works every where but Pyth 3.78/tensor 2.0

#%% Get GPU & TF status
print(tf.__version__)
from tensorflow.python.client import device_lib 
# print(device_lib.list_local_devices())  # this puts out a lot of lines (Gibberish?)
print('Conda Envronment:  ', os.environ['CONDA_DEFAULT_ENV'])
print(f'Gpu  Support:       {tf.test.is_built_with_gpu_support()}')
print(f'Cuda Support:       {tf.test.is_built_with_cuda()}')
print(f'Tensor Flow:        {tf.version.VERSION}')
pver = str(format(sys.version_info.major) +'.'+ format(sys.version_info.minor)+'.'+ format(sys.version_info.micro))
print('Python version:      {}.'.format(pver)) 
print('The numpy version:   {}.'.format(np.__version__))
# print('The panda version:   {}.'.format(pd.__version__))
tf.test.gpu_device_name()
tf.test.__package__
tf.test.__doc__
condaenv = os.environ['CONDA_DEFAULT_ENV']

starttime = time.perf_counter()
modelstart = time.strftime('%c')

#%% Load in the data
cifar10 = tf.keras.datasets.cifar10

(x_train, y_train), (x_test, y_test) = cifar10.load_data()
x_train, x_test = x_train / 255.0, x_test / 255.0
y_train, y_test = y_train.flatten(), y_test.flatten()
print("x_train.shape:", x_train.shape)
print("y_train.shape", y_train.shape)

# number of classes
K = len(set(y_train))
print("number of classes:", K)

#%% Build the model using the functional API
i = Input(shape=x_train[0].shape)
x = Conv2D(32, (3, 3), strides=2, activation='relu')(i)
x = Conv2D(64, (3, 3), strides=2, activation='relu')(x)
x = Conv2D(128, (3, 3), strides=2, activation='relu')(x)
x = Flatten()(x)
x = Dropout(0.5)(x)
x = Dense(1024, activation='relu')(x)
x = Dropout(0.2)(x)
x = Dense(K, activation='softmax')(x)

model = Model(i, x)

#%% Compile and fit
# Note: make sure you are using the GPU for this!
epochs = 15
model.compile(optimizer='adam',  # adam is a 'flavor' of gradient descent
              loss='sparse_categorical_crossentropy',
              metrics=['accuracy'])

#%% Train the model
r = model.fit(x_train, y_train, validation_data=(x_test, y_test), epochs=epochs)

endtime = time.perf_counter()
duration = round(endtime - starttime,2)

#%% Graph the model
# import pydot
# import graphviz
from tensorflow import keras
# from tensorflow.keras import layers
keras.utils.plot_model(model, show_shapes=True)

#%% Show the model in text

s2= """i = Input(shape=x_train[0].shape)
x = Conv2D(32, (3, 3), strides=2, activation='relu')(i)
x = Conv2D(64, (3, 3), strides=2, activation='relu')(x)
x = Conv2D(128, (3, 3), strides=2, activation='relu')(x)
x = Flatten()(x)
x = Dropout(0.2)(x)
x = Dense(1024, activation='relu')(x)
x = Dropout(0.2)(x)
x = Dense(K, activation='softmax')(x)"""
model.summary()
import io
s = io.StringIO()
model.summary(print_fn=lambda x: s.write(x + '\n'))
model_summary = s.getvalue()
model_summary = model_summary.replace('=','')
model_summary = model_summary.replace('_','')
model_summary = model_summary.replace('\n\n','\n')
#%% Plot loss per iteration  & Plot accuracy per iteration
import matplotlib.pyplot as plt
plt.style.use('classic')
plt.plot(r.history['loss'], label='loss')
plt.plot(r.history['val_loss'], label='val_loss')
plt.legend()

plt.plot(r.history['accuracy'], label='acc')
plt.plot(r.history['val_accuracy'], label='val_acc')
plt.legend()
plt.title(f'Udemy TensorFlow 2.0 Lecture 37 {modelstart}\n ' +
          f'Image Classification: cifar (colored animals) {x_train.shape[0]} records ' +
          f'{x_train.shape[1]} size')
plt.xlabel(f'tf2_37_CNN_cifar.py  Convolutional NN  Duration: {duration}')
plt.ylim(0,1)
plt.text(.5, .7,# transform=trans1,
         s=s2,
         wrap=True, ha='left', va='bottom',
         fontsize=10, bbox=dict(facecolor='yellow', alpha=0.5))
plt.text(.5, .2,# transform=trans1,
         s=model_summary,
         wrap=True, ha='left', va='bottom', fontname='Consolas',
         fontsize=8, bbox=dict(facecolor='pink', alpha=0.5))
plt.text(.5, .02,# transform=trans1,
         s=f'Conda Envr:  {condaenv}  ' +
         f'Gpu  Support:       {tf.test.is_built_with_gpu_support()}\n' +
         f'Python: {pver} tensorflow Ver: {tf.version.VERSION}' +
         '\nConvolutional neural network' + 
         f'\n{epochs} epochs, Duration: {duration:3.2f} seconds',# +
#         f'\n{gpus[0].name} Cuda 11.1.relgpu',
         wrap=True, ha='left', va='bottom',
         fontsize=9, bbox=dict(facecolor='aqua', alpha=0.5))
plt.show()

#%% Plot confusion matrix
from sklearn.metrics import confusion_matrix
import itertools

def plot_confusion_matrix(cm, classes,
                          normalize=False,
                          title='Confusion matrix',
                          cmap=plt.cm.Blues):
  """
  This function prints and plots the confusion matrix.
  Normalization can be applied by setting `normalize=True`.
  """
  if normalize:
      cm = cm.astype('float') / cm.sum(axis=1)[:, np.newaxis]
      print("Normalized confusion matrix")
  else:
      print('Confusion matrix, without normalization')

  print(cm)

  plt.imshow(cm, interpolation='nearest', cmap=cmap)
  plt.title(title)
  plt.colorbar()
  tick_marks = np.arange(len(classes))
  plt.xticks(tick_marks, classes, rotation=45)
  plt.yticks(tick_marks, classes)

  fmt = '.2f' if normalize else 'd'
  thresh = cm.max() / 2.
  for i, j in itertools.product(range(cm.shape[0]), range(cm.shape[1])):
      plt.text(j, i, format(cm[i, j], fmt),
               horizontalalignment="center",
               color="white" if cm[i, j] > thresh else "black")

  plt.tight_layout()
  plt.ylabel('True label')
  plt.xlabel('Predicted label')
  plt.show()


p_test = model.predict(x_test).argmax(axis=1)
cm = confusion_matrix(y_test, p_test)
#plot_confusion_matrix(cm, list(range(10)))

# label mapping
labels = '''airplane
automobile
bird
cat
deer
dog
frog
horse
ship
truck'''.split()
plot_confusion_matrix(cm, labels)

#%% Show some misclassified examples
# TODO: add label names
misclassified_idx = np.where(p_test != y_test)[0]
i = np.random.choice(misclassified_idx)
plt.imshow(x_test[i], cmap='gray')
plt.title("True label: %s Predicted: %s" % (labels[y_test[i]], labels[p_test[i]]));